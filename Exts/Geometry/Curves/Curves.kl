
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  getSamplePointPositions //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  描画されているCurveと同じ見た目のLinesを構築できるVec3[]を取得する
//  (出来上がったLinesはあくまで見た目を合わせるだけなので、Curve != Lines　であることに注意)
function Vec3[] Curves.getSamplePointPositions?(Index curveIndex){
  Vec3 result[];
  switch(this.getCurveType(curveIndex) -1){
    case 0:  //  linear
    {
      break;
    }
    case 1:  //  Bezier
    {
      break;
    }
    case 2:  //  NURBS
    {
      if(this.isClosed(curveIndex)){  //  閉じたNURBS
        result.resize(this.drawSamplesPerSpan*5);
        for(Integer i=0; i<result.size(); i++){
          result[i] = this.getPositionAtNormalizedParam(curveIndex, i/Scalar(result.size()) );
        }
      }else{  //  開いたNURBS
        result.resize(this.drawSamplesPerSpan*3+1);
        for(Integer i=0; i<result.size(); i++){
          result[i] = this.getPositionAtNormalizedParam(curveIndex, i/Scalar(result.size()-1) );
        }
      }
      break;
    }
  }
  return result;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  GetCloseOrderedListArray /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  ある座標[]からCurvesに対して近い座標のインデックス、ノーマライズドパラメータ、ウェイト値のリストを取得する
//  リストは近い順で最大4個まで

//  空間分析用に準備したLinesを使用し、各種パラメータを取得する
//  index = 検出スタートポジションの数
operator getClosestTask<<<index>>>(
  io Lines target[],
  in Curves targetCurves, 
  in Vec3 position[], 
  io LocalL4UInt32Array orderedIndex[],
  io LocalL4ScalarArray normalizedParam[], 
  io GenericVec3ArrayValue deltaPosition[],
  io LocalL4ScalarArray resultWeights[], 
  in Scalar length[],
  in Scalar maxDistance, 
  in Size maxCount) 
  {
  //  Curves内の複数のCurveそれぞれへの最も近いポジションを格納する配列を準備
  Vec3 closestPosition[]; 
  closestPosition.resize(target.size());
  //  Curves内の複数のCurveそれぞれへの最も近いポジションについて、Lineの長さに対する比率を格納する配列を準備
  Scalar ratio[]; 
  ratio.resize(target.size());
 
  for(Integer j=0; j<target.size(); j++){ //  Curve（空間分析用にLineに変換されているが）の本数だけループ
    UInt32 attrIDs[2];  //  近いlineのポイントインデックス（始点と終点）を取得するための配列を準備
    Scalar weight[2]; //  近いlineのポイントインデックスへのウェイト値を取得するための配列を準備
    //  空間分析　最も近いポジションを取得し配列に格納していく
    Ref<SpatialQuery> query = target[j].beginSpatialQuery();
      GeometryLocation location = query.getClosest(position[index], Vec3(1.0), SCALAR_INFINITE);
      target[j].getLocationAttributeIndicesAndWeights(location, attrIDs, weight);
      closestPosition[j] = target[j].getPointPosition(attrIDs[0]).linearInterpolate( target[j].getPointPosition(attrIDs[1]), weight[1]);
    target[j].endSpatialQuery(query);
    //  取得したポジションについてLineの長さに対する比率を取得し配列に格納していく
    Scalar segmentLengthSum;
    for(Integer k=0; k<attrIDs[0]; k++){
      segmentLengthSum += target[j].getPointPosition(k).distanceTo( target[j].getPointPosition(k+1) );
    }
    segmentLengthSum += target[j].getPointPosition(attrIDs[0]).distanceTo( target[j].getPointPosition(attrIDs[1]) ) * weight[1];
    ratio[j] = segmentLengthSum / length[j];
  }
  LocalL4ScalarArray orderedDistance_notUse; //  GetCloseOrderedListを実行するためのダミーデータを準備
  //  各Curveへの近いポジションの配列Vec3[]に対し、近い順でリストを作る
  GetCloseOrderedList(position[index], closestPosition, maxDistance, maxCount, orderedIndex[index], orderedDistance_notUse, resultWeights[index]);
  //  リストに沿って近いポジション値をCurveのノーマライズドパラメータに変換しリストにする
  if(resultWeights[index].count > 0){
    normalizedParam[index].resize( resultWeights[index].count );
    deltaPosition[index] = GenericVec3ArrayValue();
    deltaPosition[index].resize( resultWeights[index].count );
    for(Integer k=0; k<resultWeights[index].count; k++){
      Scalar nParam = targetCurves.getNormalizedParameterFromLengthRatio(orderedIndex[index].first4[k], ratio[ orderedIndex[index].first4[k] ]);
      normalizedParam[index].set(k, nParam);
      // 検出スタートポジションからカーブ上の最も近いポジションまでの差分座標を取得
      Vec3 v2 = targetCurves.getTangentAtNormalizedParam (orderedIndex[index].first4[k], nParam);
      Vec3 v1 = Vec3(v2.z*v2.x, abs(v2.z), v2.y*-1 );

      Quat qu;  qu.setFromDirectionAndUpvector(v2, v1);
      Mat44 im = Xfo(qu, closestPosition[ orderedIndex[index].first4[k] ], Vec3(1.0)).toMat44().inverse();
      deltaPosition[index].set(k, im.multiplyVector3(position[index]));
    }
  }
}

function Curves.getCloseOrderedListArray(
  in Vec3 positions[],  
  in Scalar maxDistance,
  in Size maxCount,
  io LocalL4UInt32Array indexList[],
  io LocalL4ScalarArray normalizedParam[],
  io GenericVec3ArrayValue deltaPosition[],
  io LocalL4ScalarArray weights[],
  ){
  indexList.resize(positions.size());
  normalizedParam.resize(positions.size());
  deltaPosition.resize(positions.size());
  weights.resize(positions.size());
  //  これから作る各Linesの長さを取得しておくための配列を準備
  //  配列の数 = Curveの数 = Linesの数
  Scalar length[];
  length.resize(this.curveCount());
  //  CurveをLinesに変換するためのデータを準備
  //  Linesに変換するのはCurveに空間分析メソッドが無いため
  Lines lines[];
  lines.resize(this.curveCount());
  //  各CurveをLinesに変換し、空間分析の準備を行う
  for(Integer i=0; i<lines.size(); i++){
    lines[i] = Lines();
    Vec3 linesPoi[] = this.getSamplePointPositions(i);  //  上記カスタムメソッドを使用
    lines[i].addLineStrip( linesPoi );
    //  Linesの長さを取得
    for(Integer j=0; j<linesPoi.size()-1; j++){
      length[i] += linesPoi[j].distanceTo(linesPoi[j+1]);
    }
    //  クローズカーブ対応
    if(this.isClosed(i)){
      lines[i].addClosedLine(linesPoi.size()-1, 0);
      length[i] += linesPoi[linesPoi.size()-1].distanceTo(linesPoi[0]);
    }
    lines[i].prepareForSpatialQueries(1, null);
  }
  //  上記オペレータを実行
  //  検索位置が3００個より多ければ並列処理
  if(positions.size() > 300){
    getClosestTask<<<positions.size()>>>(lines, this, positions, indexList, normalizedParam, deltaPosition, weights, length, maxDistance, maxCount);
  }else{
    for(Integer i=0; i<positions.size(); i++){
      getClosestTask(i, lines, this, positions, indexList, normalizedParam, deltaPosition, weights, length, maxDistance, maxCount);
    }
  }
  //  MulWeightでターゲット数に不足がないかの確認を行えるようにターゲットの数を格納しておく
  //  カウントがothers[0]を作るために5になるが、MulWeightではweightListのcountを参照するので問題ないはず
  indexList[0].count = 5;
  indexList[0].others.resize(1);
  indexList[0].others[0] = this.curveCount();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  MulWeight ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// GetCloseOrderedListArray等で取得した各情報を元に、ターゲットのカーブからタンジェント、ノーマル、ポジション、差分座標にウェイトを掛けた値を取得する

// カーブ上のパラメータポジションのポジション値xウェイト
operator MulWeightTaskPos<<<index>>>(
  io Vec3 result[], 
  in Curves target, 
  in LocalL4UInt32Array indexList[], 
  in LocalL4ScalarArray normalizedParam[], 
  in LocalL4ScalarArray weights[]
  ){
  Vec3 rest();
  for(Integer i=0; i<weights[index].count; i++){
    rest += target.getPositionAtNormalizedParam(indexList[index].first4[i], normalizedParam[index].first4[i]) * weights[index].first4[i];
  }
  result[index] = rest;
}
// カーブ上のパラメータポジションのタンジェント値xウェイト
operator MulWeightTaskTan<<<index>>>(
  io Vec3 result[], 
  in Curves target, 
  in LocalL4UInt32Array indexList[], 
  in LocalL4ScalarArray normalizedParam[], 
  in LocalL4ScalarArray weights[]
  ){
  Vec3 rest();
  for(Integer i=0; i<weights[index].count; i++){
    rest += target.getTangentAtNormalizedParam(indexList[index].first4[i], normalizedParam[index].first4[i]) * weights[index].first4[i];
  }
  result[index] = rest;
}
// カーブ上のパラメータポジションのノーマル値xウェイト
operator MulWeightTaskNom<<<index>>>(
  io Vec3 result[], 
  in Curves target, 
  in LocalL4UInt32Array indexList[], 
  in LocalL4ScalarArray normalizedParam[], 
  in LocalL4ScalarArray weights[]
  ){
  Vec3 rest();
  for(Integer i=0; i<weights[index].count; i++){
    rest += target.getNormalAtNormalizedParam(indexList[index].first4[i], normalizedParam[index].first4[i]) * weights[index].first4[i];
  }
  result[index] = rest;
}
// 検出スタートポジションからカーブ上の最も近いポジションまでの差分座標xウェイト
operator MulWeightTaskDlt<<<index>>>(
  io Vec3 result[], 
  in Curves target, 
  in LocalL4UInt32Array indexList[], 
  in LocalL4ScalarArray normalizedParam[], 
  in GenericVec3ArrayValue deltaPosition[], 
  in LocalL4ScalarArray weights[],
  ){
  Vec3 rest();
  for(Integer i=0; i<weights[index].count; i++){
    Vec3 restTan = target.getTangentAtNormalizedParam(indexList[index].first4[i], normalizedParam[index].first4[i]);
    Vec3 restNom = Vec3(restTan.z*restTan.x, abs(restTan.z), restTan.y*-1 );

    Vec3 restPos = target.getPositionAtNormalizedParam(indexList[index].first4[i], normalizedParam[index].first4[i]);
    Quat qu;
    qu.setFromDirectionAndUpvector(restTan, restNom);
    Mat44 gM = Xfo(qu, restPos, Vec3(1.0)).toMat44();
    rest += gM.multiplyVector3(deltaPosition[index].get(i)) * weights[index].first4[i];
  }
  result[index] = rest;
}
function Curves.mulWeight(
  io Vec3 result[], 
  in Integer getValueType, 
  in LocalL4UInt32Array indexList[], 
  in LocalL4ScalarArray normalizedParam[], 
  in GenericVec3ArrayValue deltaPosition[], 
  in LocalL4ScalarArray weights[],
  ){
  //  リストを制作した際のターゲット数と今回参照するターゲット数に不足がないかを確認する
  //  indexList[0].others[0]にターゲット数が格納されているためcountの数が実際のターゲット数とは異なるので、ループではweightsのサイズを使用する
  if(indexList[0].others[0] > this.curveCount()){
    setError("Curves.MulWeight node : IndexList require count = "+indexList[0].others[0]+". But Curve count = "+this.curveCount());
  }else{
    result.resize(weights.size());
    switch(getValueType){
      case 0:
        MulWeightTaskPos<<<result.size()>>>(result, this, indexList, normalizedParam, weights);
        break;
      case 1:
        MulWeightTaskTan<<<result.size()>>>(result, this, indexList, normalizedParam, weights);
        break;
      case 2:
        MulWeightTaskNom<<<result.size()>>>(result, this, indexList, normalizedParam, weights);
        break;
      case 3:
        MulWeightTaskDlt<<<result.size()>>>(result, this, indexList, normalizedParam, deltaPosition, weights);
        break;
    }
  }
}
