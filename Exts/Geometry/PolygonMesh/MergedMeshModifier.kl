//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MergedMeshModifier ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// マージ時の情報を元にしてクローンマージ後のメッシュの形状の編集を行うことで処理負荷の高いマージを繰り返し行わなくする

//  クローンマージメッシュに対して、マージ時の各クローンメッシュのXfoを更新するためのオペレータ
//  indexはマージメッシュの頂点数
operator MergedMeshUpdateXfo<<<index>>>(
  io PolygonMeshTopology mesh,
  io Vec3 positions[], 
  in Vec3 sourcePositions[], 
  in Size baseMeshPointCount,
  in Size sourceMeshPointCount,
  in Xfo updateXfo[],
  ){
    Size i = index + baseMeshPointCount;  //  マージ時にベースとなるメッシュがあった場合に、編集結果を返す頂点番号を計算しておく
  Vec3 position;
  Size XfoID = index / sourceMeshPointCount;  //  何個目のXfoでクローン配置されたメッシュなのかを検出
  Size sourceMeshPoiID = index % sourceMeshPointCount;  //  クローンメッシュの何番目の頂点なのかを算出
  position = updateXfo[XfoID].transformVector(sourcePositions[sourceMeshPoiID]);  //  アップデートするXfo（グローバル値）にクローンメッシュの頂点位置Vec3（ローカル値）を掛ける

  mesh.setPointAttribute( i, positions, position );
}
//  クローンマージメッシュに対して、マージ時の各クローンメッシュのXfoの更新とブレンドシェイプを行うためのオペレータ
//  indexはマージメッシュの頂点数
operator MergedMeshUpdateXfoAndBlendShape<<<index>>>(
  io PolygonMeshTopology mesh,
  io Vec3 positions[], 
  in Vec3 sourcePositions[],
  in GenericVec3ArrayValue blendshapeDelta[],
  in LocalL4UInt32Array[] BSIndexList,
  in LocalL4ScalarArray[] blendshapeWeights,
  in Size baseMeshPointCount,
  in Size sourceMeshPointCount,
  in Xfo updateXfo[],
  ){
  Size i = index + baseMeshPointCount;
  Vec3 position;
  Size XfoID = index / sourceMeshPointCount;
  Size sourceMeshPoiID = index % sourceMeshPointCount;
  
  for(Integer j=0; j<blendshapeWeights[XfoID].count; j++){
    position += blendshapeDelta[ BSIndexList[XfoID].first4[j] ].get(sourceMeshPoiID) * blendshapeWeights[XfoID].first4[j];
  }
  position = updateXfo[XfoID].transformVector(sourcePositions[sourceMeshPoiID] + position);
  mesh.setPointAttribute( i, positions, position );
}

function PolygonMesh.mergedMeshClonesModifier!(
  in Xfo mergedXfos[],
  in Xfo updateXfos[],
  in PolygonMesh source,
  in Boolean applyBlendShape,
  in GenericVec3ArrayValue blendshapeDelta[],
  in LocalL4UInt32Array blendShapeIndexList[],
  in LocalL4ScalarArray blendshapeWeights[]
  ){
  //  入力がない場合は中止
  if(mergedXfos.size() == 0 || updateXfos.size() == 0 || blendshapeDelta.size() == 0 || blendShapeIndexList.size() == 0 || blendshapeWeights.size() == 0){
    setError("\
MergedMeshClonesModifier node : Some inputs are 0. \
mergedXfos = "+mergedXfos.size()+", \
updateXfos = "+updateXfos.size()+", \
blendshapeDelta = "+blendshapeDelta.size()+", \
blendShapeIndexList = "+blendShapeIndexList.size()+", \
blendshapeWeights = "+blendshapeWeights.size()
    );
    return;
  }
  //　マージ時にベースとなったメッシュの頂点数を算出しておく
  Size baseMeshPointCount;
  baseMeshPointCount = this.pointCount() - source.pointCount()*mergedXfos.size();
  //  マージ時のXfoの数と今回更新するXfoの数が同じか、ターゲットの数は不足していないかのチェック後に上記オペレータを実行
  if(mergedXfos.size() != updateXfos.size()){
    setError("MergedMeshModifier node : mergedXfos count don't same updateXfos count. mergedXfos is "+mergedXfos.size()+" : updateXfos is "+ updateXfos.size());
  }else if(blendShapeIndexList[0].others[0] > blendshapeDelta.size()){
    setError("MergedMeshModifier node : IndexList require count = "+blendShapeIndexList[0].others[0]+". But blend shape target count = "+blendshapeDelta.size());
  }else{
    Ref<Vec3Attribute> positionsAttribute = this.getAttributes().positionsAttribute;
    Ref<Vec3Attribute> positionsAttribute2 = source.getAttributes().positionsAttribute;
    
    if(applyBlendShape){
      //  ブレンドシェイプに必要な情報が不足している場合はエラーメッセージ
      if(blendshapeDelta.size() == 0 || blendShapeIndexList.size() == 0 || blendshapeWeights.size() == 0){
        setError("MergedMeshModifier node : blendshapeDelta = "+blendshapeDelta.size()+", blendShapeIndexList = "+blendShapeIndexList.size()+", blendshapeWeights = "+blendshapeWeights.size());
      }else{
        MergedMeshUpdateXfoAndBlendShape<<<this.pointCount()>>>(
          this.topology, 
          positionsAttribute.values, 
          positionsAttribute2.values,
          blendshapeDelta,
          blendShapeIndexList,
          blendshapeWeights,
          baseMeshPointCount,
          source.pointCount(),
          updateXfos
        );
      }
    }else{
      MergedMeshUpdateXfo<<<this.pointCount()>>>(
        this.topology, 
        positionsAttribute.values, 
        positionsAttribute2.values, 
        baseMeshPointCount,
        source.pointCount(),
        updateXfos
      );
    }
  }
}
